// Generated by CoffeeScript 1.6.1
"use strict";
var broadcastInfo, broadcastRoomAudience, clients, createRoom, doUserName, htmlEntities, http, joinRoom, kick, listRooms, rooms, server, userNames, webSocketServer, webSocketsServerPort, wsServer;

webSocketsServerPort = 8088;

webSocketServer = require('websocket').server;

http = require('http');

/*
 * Global variables
*/


clients = [];

userNames = {};

userNames['nono'] = true;

rooms = [
  {
    name: 'lounge',
    owner: 'system'
  }, {
    name: 'entrance',
    owner: 'system'
  }
];

/*
#  Helper function for escaping input strings
*/


htmlEntities = function(str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

createRoom = function(connection, name, userName) {
  rooms.push({
    name: name,
    owner: userName
  });
  return listRooms(connection);
};

listRooms = function(connection) {
  return connection.sendUTF(JSON.stringify({
    type: 'roomList',
    data: rooms
  }));
};

joinRoom = function(userName, room, index) {
  var clnt;
  console.log((userName || 'listener') + ' should join ' + room + ', index: ' + index);
  clnt = clients[index];
  if (!clnt) {
    return;
  }
  clnt.room = room;
  clnt.userName = userName;
  return broadcastRoomAudience(room);
};

broadcastRoomAudience = function(room) {
  var client, clientell, json, _i, _len;
  clientell = [];
  for (_i = 0, _len = clients.length; _i < _len; _i++) {
    client = clients[_i];
    if (client.room === room) {
      clientell.push(client.userName);
    }
  }
  json = JSON.stringify({
    type: 'viewers',
    data: clientell
  });
  broadcastInfo(json, room);
  return room;
};

doUserName = function(connection, message) {
  var userName;
  userName = htmlEntities(message);
  console.log((new Date()) + ' Checking: ' + userName);
  if (userNames[userName]) {
    connection.sendUTF(JSON.stringify({
      type: 'refuseNickname',
      data: userName
    }));
    console.log((new Date()) + ' User refused (existing): ' + userName);
    return false;
  }
  userNames[userName] = true;
  connection.sendUTF(JSON.stringify({
    type: 'acceptNickname',
    data: userName
  }));
  console.log((new Date()) + ' User is known as: ' + userName);
  return userName;
};

kick = function(userName, data) {
  var client, r, room, _fn, _i, _len;
  room = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = rooms.length; _i < _len; _i++) {
      r = rooms[_i];
      _results.push((function(r) {
        if (r.name === data.room) {
          return r;
        }
      })(r));
    }
    return _results;
  })();
  if (room.user !== userName) {
    return;
  }
  _fn = function(client) {
    if (client.room === data.room) {
      client.room = '';
      return client.connection.sendUTF(JSON.stringify({
        owner: userName,
        type: 'kick',
        room: data.room
      }));
    }
  };
  for (_i = 0, _len = clients.length; _i < _len; _i++) {
    client = clients[_i];
    _fn(client);
  }
  return broadcastRoomAudience(room);
};

broadcastInfo = function(json, inRoom) {
  var client, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = clients.length; _i < _len; _i++) {
    client = clients[_i];
    _results.push((function(client, inRoom) {
      if (client.room === inRoom) {
        return client.connection.sendUTF(json);
      }
    })(client, inRoom));
  }
  return _results;
};

/*
 * HTTP server
*/


server = http.createServer(function(request, response) {});

server.listen(webSocketsServerPort, function() {
  return console.log((new Date()) + " Server is listening on port " + webSocketsServerPort);
});

/*
 * WebSocket server
*/


wsServer = new webSocketServer({
  httpServer: server
});

wsServer.on('request', function(request) {
  var con, connection, inRoom, index, userName;
  console.log((new Date()) + ' Connection from origin ' + request.origin + '.');
  /*
  # accept connection - you should check 'request.origin' to make sure that
  # client is connecting from your website
  # (http://en.wikipedia.org/wiki/Same_origin_policy)
  */

  connection = request.accept(null, request.origin);
  con = {
    connection: connection,
    room: '',
    userName: false
  };
  index = clients.push(con) - 1;
  userName = false;
  inRoom = false;
  console.log((new Date()) + ' Connection accepted.');
  connection.on('message', function(messageObj) {
    var chat, e, json, message, obj;
    if (messageObj.type !== 'utf8') {
      console.log('Rejecting funny stuff');
      return;
    }
    try {
      message = JSON.parse(messageObj.utf8Data);
    } catch (_error) {
      e = _error;
      console.log('This doesn\'t look like a valid JSON: ', messageObj.utf8Data);
    }
    console.log((new Date()) + ' Received Message type: ' + message.type + ' data: ' + message.data);
    if (message.type === 'listRooms') {
      listRooms(connection);
      return;
    }
    if (message.type === 'kick') {
      kick(userName, message.data);
      return;
    }
    if (message.type === 'join') {
      inRoom = joinRoom(userName, message.data, index);
      return;
    }
    if (message.type === 'room') {
      createRoom(connection, message.data, userName);
      return;
    }
    if (message.type === 'handle') {
      userName = doUserName(connection, message.data);
      console.log((new Date()) + ' Recognize user: ' + userName);
      return;
    }
    chat = message.data;
    console.log((new Date()) + ' Received Message from ' + userName + ': ' + chat);
    obj = {
      time: (new Date()).getTime(),
      text: htmlEntities(chat),
      author: userName,
      room: inRoom
    };
    if (!userName) {
      obj.text = "Please choose a valid nick to be able to chat";
      obj.author = '(system says)';
      connection.sendUTF(JSON.stringify({
        type: 'message',
        data: obj
      }));
      return;
    }
    json = JSON.stringify({
      type: 'message',
      data: obj
    });
    broadcastInfo(json, inRoom);
  });
  return connection.on('close', function(connection) {
    if (userName === false) {
      return;
    }
    console.log((new Date()) + " Peer " + connection.remoteAddress + " disconnected.");
    clients.splice(index, 1);
  });
});
